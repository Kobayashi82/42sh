NOTES:
		This is a reference man page for when I implement my own


42SH(1)                     General Commands Manual                    42SH(1)

NAME
       42sh


SYNOPSIS
       42sh [OPTIONS] [FILE]


DESCRIPTION
       42sh  is  an  sh-compatible  command language interpreter that executes
       commands read from the standard input or from a file.

       42sh is implemented in C Language.


OPTIONS
       In addition to the single-character shell options documented in the de-
       scription of the set builtin command, 42sh interprets the following op-
       tions when it is invoked:

       -c <command>
            If  the -c option is present, then commands are read from command.
            If there are arguments after the command, they are assigned to the
            positional parameters, starting with $0.
       [-+]O [shopt_option]
            shopt_option is one of the shell options  accepted  by  the  shopt
            builtin  (see  SHELL  BUILTIN COMMANDS below).  If shopt_option is
            present, -O sets the value of  that  option;  +O  unsets  it.   If
            shopt_option  is  not  supplied, the names and values of the shell
            options accepted by shopt are printed on the standard output.   If
            the  invocation  option is +O, the output is displayed in a format
            that may be reused as input.

       42sh also interprets a number of multi-character  options.   These  op-
       tions  must  appear on the command line before the single-character op-
       tions to be recognized.

       --ast-print
            Activate the ast printer.
       --norc
            Do not read and execute the system wide  initialization  (desacti-
            vates the ressource reader).
       --version
            Show version information for this instance of 42sh on the standard
            output and exit successfully.


INVOCATION
       An  interactive  shell  is one started without non-option arguments and
       without the -c option whose standard input and error are both connected
       to terminals.  PS1 is set and $- includes i if 42sh is interactive, al-
       lowing a shell script or a startup file to test this state.


DEFINITIONS
       The following definitions are used throughout the rest  of  this  docu-
       ment.
       blank
            A space or tab.
       word A sequence of characters considered as a single unit by the shell.
            Also known as a token.
       name A word consisting only of alphanumeric characters and underscores,
            and beginning with an alphabetic character or an underscore.  Also
            referred to as an identifier.
       metacharacter
            A character that, when unquoted, separates words.  One of the fol-
            lowing: |  & ; ( ) < > space tab
       control operator
            A  token  that performs a control function.  It is one of the fol-
            lowing symbols: || & && ; ;; ( ) | <newline>


RESERVED WORDS
       Reserved words are words that have a special meaning to the shell.  The
       following words are recognized as reserved when unquoted and either the
       first word of a simple command (see SHELL GRAMMAR below) or  the  third
       word of a case or for command: case do done elif else esac fi for if in
       then until while { } time [[ ]]


SHELL GRAMMAR
   Simple Commands
       A  simple  command  is a sequence of optional variable assignments fol-
       lowed by blank-separated words and redirections, and  terminated  by  a
       control operator.  The first word specifies the command to be executed,
       and  is passed as argument zero.  The remaining words are passed as ar-
       guments to the invoked command.

       The return value of a simple command is its exit status,  or  128+n  if
       the command is terminated by signal n.

   Pipelines
       A pipeline is a sequence of one or more commands separated by the char-
       acter |.  The format for a pipeline is:

              command [| command2 ...]

       The  standard output of command is connected via a pipe to the standard
       input of command2.  This connection is performed  before  any  redirec-
       tions specified by the command (see REDIRECTION below).

       The return status of a pipeline is the exit status of the last command.

       Each  command in a pipeline is executed as a separate process (i.e., in
       a subshell).

   Lists
       A list is a sequence of one or more pipelines separated by one  of  the
       operators ;, &, &&, or ||, and optionally terminated by one of ;, &, or
       <newline>.

       Of these list operators, && and || have equal precedence, followed by ;
       and &, which have equal precedence.

       A  sequence  of  one or more newlines may appear in a list instead of a
       semicolon to delimit commands.

       If a command is terminated by the control operator &,  the  shell  exe-
       cutes  the command in the background in a subshell.  The shell does not
       wait for the command to finish, and the return status is  0.   Commands
       separated  by  a  ; are executed sequentially; the shell waits for each
       command to terminate in turn.  The return status is the exit status  of
       the last command executed.

       The  control operators && and || denote AND lists and OR lists, respec-
       tively.  An AND list has the form

              command1 && command2

       command2 is executed if, and only if, command1 returns an  exit  status
       of zero.

       An OR list has the form

              command1 || command2

       command2  is  executed  if and only if command1 returns a non-zero exit
       status.  The return status of AND and OR lists is the  exit  status  of
       the last command executed in the list.

   Compound Commands
       A compound command is one of the following:

       { list; }
              list  is simply executed in the current shell environment.  list
              must be terminated with a newline or semicolon.  This  is  known
              as  a  group  command.   The return status is the exit status of
              list.  Note that unlike the metacharacters ( and ), { and }  are
              reserved words and must occur where a reserved word is permitted
              to  be  recognized.   Since they do not cause a word break, they
              must be separated from list by whitespace.

       for name [ in word ] ; do list ; done
              The list of words following in is expanded, generating a list of
              items.  The variable name is set to each element of this list in
              turn, and list is executed each time.  If the in word  is  omit-
              ted,  the for command executes list once for each positional pa-
              rameter that is set (see PARAMETERS below).  The  return  status
              is  the  exit  status of the last command that executes.  If the
              expansion of the items following in results in an empty list, no
              commands are executed, and the return status is 0.

       case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac
              A case command first expands word, and tries to match it against
              each pattern in turn, using the same matching rules as for path-
              name expansion (see Pathname Expansion below).  The word is  ex-
              panded  using tilde expansion, parameter and variable expansion,
              arithmetic substitution, command substitution, process substitu-
              tion and quote removal.  Each pattern examined is expanded using
              tilde expansion, parameter and  variable  expansion,  arithmetic
              substitution,  command  substitution,  and process substitution.
              When a match is found, the corresponding list is executed.   Af-
              ter  the  first match, no subsequent matches are attempted.  The
              exit status is zero if no pattern matches.  Otherwise, it is the
              exit status of the last command executed in list.

       if list; then list; [ elif list; then list; ] ... [ else list; ] fi
              The if list is executed.  If its exit status is zero,  the  then
              list  is  executed.   Otherwise,  each  elif list is executed in
              turn, and if its exit status is  zero,  the  corresponding  then
              list is executed and the command completes.  Otherwise, the else
              list  is executed, if present.  The exit status is the exit sta-
              tus of the last command executed, or zero if no condition tested
              true.

       while list; do list; done
       until list; do list; done
              The while command continuously executes the do list as  long  as
              the  last  command  in list returns an exit status of zero.  The
              until command is identical to the while command, except that the
              test is negated; the do list is executed as  long  as  the  last
              command in list returns a non-zero exit status.  The exit status
              of  the  while and until commands is the exit status of the last
              do list command executed, or zero if none was executed.


COMMENTS
       In a non-interactive shell, or an interactive shell in which the  shopt
       builtin is enabled (see SHELL BUILTIN COMMANDS below), a word beginning
       with # causes that word and all remaining characters on that line to be
       ignored.


QUOTING
       Quoting  is used to remove the special meaning of certain characters or
       words to the shell.  Quoting can be used to disable  special  treatment
       for special characters, to prevent reserved words from being recognized
       as such, and to prevent parameter expansion.

       Each  of  the metacharacters listed above under DEFINITIONS has special
       meaning to the shell and must be quoted if it is to represent itself.

       There are  three  quoting  mechanisms:  the  escape  character,  single
       quotes, and double quotes.

       A  non-quoted  backslash (\) is the escape character.  It preserves the
       literal value of the next character that follows, with the exception of
       <newline>.  If a \<newline> pair appears, and the backslash is not  it-
       self quoted, the \<newline> is treated as a line continuation (that is,
       it is removed from the input stream and effectively ignored).

       Enclosing  characters  in  single quotes preserves the literal value of
       each character within the quotes.  A single quote may not occur between
       single quotes, even when preceded by a backslash.

       Enclosing characters in double quotes preserves the  literal  value  of
       all  characters  within the quotes, with the exception of $, `, \, and,
       when history expansion is enabled, !.  The characters $  and  `  retain
       their  special meaning within double quotes.  The backslash retains its
       special meaning only when followed by one of the following  characters:
       $,  `, "", \, or <newline>.  A double quote may be quoted within double
       quotes by preceding it with a backslash.  If enabled, history expansion
       will be performed unless an !  appearing in double  quotes  is  escaped
       using a backslash.  The backslash preceding the !  is not removed.

       The  special  parameters  *  and  @ have special meaning when in double
       quotes (see PARAMETERS below).

       Words of the form $'string' are treated specially.  The word expands to
       string, with backslash-escaped characters replaced as specified by  the
       ANSI  C  standard.  Backslash escape sequences, if present, are decoded
       as follows:
              \a     alert (bell)
              \b     backspace
              \e     an escape character
              \f     form feed
              \n     new line
              \r     carriage return
              \t     horizontal tab
              \v     vertical tab
              \\     backslash
              \'     single quote
              \nnn   the eight-bit character whose value is  the  octal  value
                     nnn (one to three digits)
              \xHH   the  eight-bit  character  whose value is the hexadecimal
                     value HH (one or two hex digits)
              \cx    a control-x character

       The expanded result is single-quoted, as if the  dollar  sign  had  not
       been present.

       A  double-quoted  string  preceded  by a dollar sign ($) will cause the
       string to be translated according to the current locale.  If  the  cur-
       rent  locale  is C or POSIX, the dollar sign is ignored.  If the string
       is translated and replaced, the replacement is double-quoted.


PARAMETERS
       A parameter is an entity that stores values.  It can be a name, a  num-
       ber,  or one of the special characters listed below under Special Para-
       meters.  A variable is a parameter denoted by a name.  A variable has a
       value and zero or more attributes.

       A parameter is set if it has been assigned a value.  The null string is
       a valid value.

       A variable may be assigned to by a statement of the form

              name=[value]

       If value is not given, the variable is assigned the null  string.   All
       values  undergo tilde expansion, parameter and variable expansion, com-
       mand substitution, arithmetic expansion, and quote removal (see  EXPAN-
       SION  below).   Word  splitting is not performed, with the exception of
       "$@" as explained below under Special Parameters.   Pathname  expansion
       is not performed.

   Special Parameters
       The  shell  treats  several parameters specially.  These parameters may
       only be referenced; assignment to them is not allowed.
       *      Expands to the positional parameters, starting from  one.   When
              the  expansion occurs within double quotes, it expands to a sin-
              gle word with the value of each parameter separated by the first
              character of the IFS special variable.  That is, "$*" is equiva-
              lent to "$1c$2c...", where c is the first character of the value
              of the IFS variable.  If IFS is unset, the parameters are  sepa-
              rated  by  spaces.   If  IFS  is null, the parameters are joined
              without intervening separators.
       @      Expands to the positional parameters, starting from  one.   When
              the  expansion  occurs  within double quotes, each parameter ex-
              pands to a separate word.  That is, "$@" is equivalent  to  "$1"
              "$2"  ...   If the double-quoted expansion occurs within a word,
              the expansion of the first parameter is joined with  the  begin-
              ning  part  of  the original word, and the expansion of the last
              parameter is joined with the last part  of  the  original  word.
              When  there  are no positional parameters, "$@" and $@ expand to
              nothing (i.e., they are removed).
       #      Expands to the number of positional parameters in decimal.
       ?      Expands to the status of the most recently  executed  foreground
              pipeline.
       -      Expands  to  the  current option flags as specified upon invoca-
              tion, by the set builtin command, or those set by the shell  it-
              self
       $      Expands  to  the  process ID of the shell.  In a () subshell, it
              expands to the process ID of the current  shell,  not  the  sub-
              shell.
       !      Expands  to  the  process ID of the most recently executed back-
              ground (asynchronous) command.
       _      At shell startup, set to the absolute pathname  used  to  invoke
              the  shell or shell script being executed as passed in the envi-
              ronment or argument list.  Subsequently, expands to the last ar-
              gument to the previous command, after expansion.   Also  set  to
              the  full  pathname  used  to  invoke  each command executed and
              placed in the environment exported to that command.  When check-
              ing mail, this parameter holds the name of the  mail  file  cur-
              rently being checked.

   Shell Variables
       The following variables are set by the shell:

       OLDPWD The previous working directory as set by the cd command.
       PWD    The current working directory as set by the cd command.
       RANDOM Each time this parameter is referenced, a random integer between
              0 and 32767 is generated.  The sequence of random numbers may be
              initialized by assigning a value to RANDOM.  If RANDOM is unset,
              it  loses its special properties, even if it is subsequently re-
              set.
       SHELLOPTS
              A colon-separated list of enabled shell options.  If this  vari-
              able  is  in the environment when 42sh starts up, each shell op-
              tion in the list will be  enabled  before  reading  any  startup
              files.  This variable is read-only.
       UID    Expands to the user ID of the current user, initialized at shell
              startup.  This variable is readonly.

       The following variables are used by the shell.  In some cases, 42sh as-
       signs a default value to a variable; these cases are noted below.

       CDPATH The  search  path for the cd command.  This is a colon-separated
              list of directories in which the shell looks for destination di-
              rectories specified by  the  cd  command.   A  sample  value  is
              ".:~:/usr".
       HISTCONTROL
              A  colon-separated  list  of values controlling how commands are
              saved on the history list.   If  the  list  of  values  includes
              ignorespace,  lines  which  begin with a space character are not
              saved in the history list.  A value of ignoredups  causes  lines
              matching the previous history entry to not be saved.  A value of
              ignoreboth is shorthand for ignorespace and ignoredups.  A value
              of erasedups causes all previous lines matching the current line
              to  be  removed from the history list before that line is saved.
              Any value not in the above list is ignored.  If  HISTCONTROL  is
              unset,  or does not include a valid value, all lines read by the
              shell parser are saved on the history list, subject to the value
              of HISTIGNORE.  The second and subsequent lines of a  multi-line
              compound  command  are  not tested, and are added to the history
              regardless of the value of HISTCONTROL.
       HISTSIZE
              The number of commands to remember in the command  history  (see
              HISTORY below).  The default value is 500.
       HOME   The home directory of the current user; the default argument for
              the cd builtin command.  The value of this variable is also used
              when performing tilde expansion.
       IFS    The Internal Field Separator that is used for word splitting af-
              ter  expansion  and  to  split  lines  into  words with the read
              builtin  command.   The  default  value  is  ``<space><tab><new-
              line>''.
       PATH   The  search  path for commands.  It is a colon-separated list of
              directories in which the shell looks for commands  (see  COMMAND
              EXECUTION  below).   A  zero-length (null) directory name in the
              value of PATH indicates the current directory.  A null directory
              name may appear as two adjacent colons,  or  as  an  initial  or
              trailing  colon.   The  default path is system-dependent, and is
              set by the administrator who installs 42sh.  A common  value  is
              ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin''.
       PS1    The  value  of  this parameter is expanded (see PROMPTING below)
              and used as the primary prompt string.   The  default  value  is
              ``\s-\v\$ ''.
       PS2    The  value of this parameter is expanded as with PS1 and used as
              the secondary prompt string.  The default is ``> ''.
       SHELL  The full pathname to the shell is kept in this environment vari-
              able.  If it is not set when the shell starts, 42sh  assigns  to
              it the full pathname of the current user's login shell.

EXPANSION
       Expansion is performed on the command line after it has been split into
       words.   There  are  two kinds of expansion performed: tilde expansion,
       pathname expansion.
       The order of expansions is: tilde expansion and pathname expansion.
   Tildes Expansion
       If a word begins with an unquoted tilde character  (`~'),  all  of  the
       characters  preceding  the  first unquoted slash (or all characters, if
       there is no unquoted slash) are considered a tilde-prefix.  If none  of
       the  characters  in  the tilde-prefix are quoted, the characters in the
       tilde-prefix following the tilde are treated as a possible login  name.
       If  this  login name is the null string, the tilde is replaced with the
       value of the shell parameter HOME.  If HOME is unset, the  home  direc-
       tory  of  the  user executing the shell is substituted instead.  Other-
       wise, the tilde-prefix is replaced with the home  directory  associated
       with the specified login name.
       If  the tilde-prefix is a `~+', the value of the shell variable PWD re-
       places the tilde-prefix.  If the tilde-prefix is a `~-', the  value  of
       the  shell variable OLDPWD, if it is set, is substituted.  If the char-
       acters following the tilde in the tilde-prefix consist of a  number  N,
       optionally  prefixed  by  a  `+' or a `-', the tilde-prefix is replaced
       with the corresponding element from the directory stack.  If the  char-
       acters  following  the  tilde  in  the tilde-prefix consist of a number
       without a leading `+' or `-', `+' is assumed.
       If the login name is invalid, or the tilde expansion fails, the word is
       unchanged.
       Each variable assignment is checked for unquoted tilde-prefixes immedi-
       ately following a : or the first =.  In these cases, tilde expansion is
       also performed.  Consequently, one may use file names  with  tildes  in
       assignments  to  PATH,  and  CDPATH, and the shell assigns the expanded
       value.
   Pathname Expansion
       After word splitting, 42sh scans each word for the characters *, ?, and
       [.  If one of these characters appears, then the word is regarded as  a
       pattern,  and replaced with an alphabetically sorted list of file names
       matching the pattern.  When a pattern is used for  pathname  expansion,
       the  character ``.''  at the start of a name or immediately following a
       slash must be matched explicitly.  When matching a pathname, the  slash
       character must always be matched explicitly.  In other cases, the ``.''
       character is not treated specially.
       Pattern Matching
       Any character that appears in a pattern, other than the special pattern
       characters  described below, matches itself.  The NUL character may not
       occur in a pattern.  A backslash escapes the following  character;  the
       escaping  backslash  is  discarded  when matching.  The special pattern
       characters must be quoted if they are to be matched literally.
       The special pattern characters have the following meanings:
       *      Matches any string, including the null string.
       ?      Matches any single character.
       [...]  Matches any one of the enclosed characters.  A pair  of  charac-
              ters separated by a hyphen denotes a range expression; any char-
              acter  that sorts between those two characters, inclusive, using
              the current locale's collating sequence and  character  set,  is
              matched.   If the first character following the [ is a !  or a ^
              then any character not enclosed is matched.  A - may be  matched
              by  including it as the first or last character in the set.  A ]
              may be matched by including it as the  first  character  in  the
              set.

              Within  [  and  ],  character classes can be specified using the
              syntax [:class:], where class is one of  the  following  classes
              defined in the POSIX standard:
              alnum  alpha  ascii  blank  cntrl  digit graph lower print punct
              space upper word xdigit
              A character class matches any character belonging to that class.
              The word character class matches letters, digits, and the  char-
              acter _.

              Within  [ and ], an equivalence class can be specified using the
              syntax [=c=], which matches all characters with the same  colla-
              tion  weight (as defined by the current locale) as the character
              c.

              Within [ and ], the syntax [.symbol.] matches the collating sym-
              bol symbol.

REDIRECTION
       Before a command is executed, its input and output  may  be  redirected
       using  a  special  notation  interpreted by the shell.  Redirection may
       also be used to open and close files for the  current  shell  execution
       environment.  The following redirection operators may precede or appear
       anywhere within a simple command or may follow a command.  Redirections
       are processed in the order they appear, from left to right.
       In  the  following descriptions, if the file descriptor number is omit-
       ted, and the first character of the  redirection  operator  is  <,  the
       redirection  refers  to the standard input (file descriptor 0).  If the
       first character of the  redirection  operator  is  >,  the  redirection
       refers to the standard output (file descriptor 1).
       Note  that  the order of redirections is significant.  For example, the
       command
              ls > dirlist 2>&1
       directs both standard output and standard error to  the  file  dirlist,
       while the command
              ls 2>&1 > dirlist
       directs  only the standard output to file dirlist, because the standard
       error was duplicated as standard output before the standard output  was
       redirected to dirlist.
       42sh handles several filenames specially when they are used in redirec-
       tions, as described in the following table:
              /dev/fd/fd
                     If  fd  is  a valid integer, file descriptor fd is dupli-
                     cated.
              /dev/stdin
                     File descriptor 0 is duplicated.
              /dev/stdout
                     File descriptor 1 is duplicated.
              /dev/stderr
                     File descriptor 2 is duplicated.
              A failure to open or create a file  causes  the  redirection  to
              fail.
              Redirections  using  file  descriptors  greater than 9 should be
              used with care, as they may conflict with file  descriptors  the
              shell uses internally.
   Redirecting Input
       Redirection of input causes the file whose name results from the expan-
       sion  of  word  to  be  opened for reading on file descriptor n, or the
       standard input (file descriptor 0) if n is not specified.
       The general format for redirecting input is:
              [n]<word
   Redirecting Output
       Redirection of output causes the file whose name results from  the  ex-
       pansion  of  word to be opened for writing on file descriptor n, or the
       standard output (file descriptor 1) if n is not specified.  If the file
       does not exist it is created; if it does exist it is truncated to  zero
       size.
       The general format for redirecting output is:
              [n]>word
   Appending Redirected Output
       Redirection  of  output  in this fashion causes the file whose name re-
       sults from the expansion of word to be opened for appending on file de-
       scriptor n, or the standard output (file descriptor  1)  if  n  is  not
       specified.  If the file does not exist it is created.
       The general format for appending output is:
              [n]>>word
   Redirecting Standard Output and Standard Error
       42sh  allows both the standard output (file descriptor 1) and the stan-
       dard error output (file descriptor 2) to  be  redirected  to  the  file
       whose name is the expansion of word with this construct.
       There  are two formats for redirecting standard output and standard er-
       ror:
              &>word
       and
              >&word
       Of the two forms, the first is preferred.  This is semantically equiva-
       lent to
              >word 2>&1
   Here Documents
       This type of redirection instructs the shell to  read  input  from  the
       current  source  until  a  line  containing only word (with no trailing
       blanks) is seen.  All of the lines read up to that point are then  used
       as the standard input for a command.
       The format of here-documents is:
              <<[-]word
                      here-document
              delimiter
       No  parameter expansion, command substitution, arithmetic expansion, or
       pathname expansion is performed on word.  If any characters in word are
       quoted, the delimiter is the result of quote removal on word,  and  the
       lines  in the here-document are not expanded.  If word is unquoted, all
       lines of the here-document are subjected to parameter  expansion,  com-
       mand  substitution,  and arithmetic expansion.  In the latter case, the
       character sequence \<newline> is ignored, and \ must be used  to  quote
       the characters \, $, and `.
       If the redirection operator is <<-, then all leading tab characters are
       stripped  from input lines and the line containing delimiter.  This al-
       lows here-documents within shell scripts to be indented  in  a  natural
       fashion.
   Duplicating File Descriptors
       The redirection operator
              [n]<&word
       is used to duplicate input file descriptors.  If word expands to one or
       more  digits,  the file descriptor denoted by n is made to be a copy of
       that file descriptor.  If the digits in word do not specify a file  de-
       scriptor open for input, a redirection error occurs.  If word evaluates
       to -, file descriptor n is closed.  If n is not specified, the standard
       input (file descriptor 0) is used.
       The operator
              [n]>&word
       is  used  similarly  to duplicate output file descriptors.  If n is not
       specified, the standard output (file descriptor 1)  is  used.   If  the
       digits  in  word  do  not  specify a file descriptor open for output, a
       redirection error occurs.  As a special case, if n is omitted, and word
       does not expand to one or more digits, the standard output and standard
       error are redirected as described previously.
   Moving File Descriptors
       The redirection operator
              [n]<&digit-
       moves the file descriptor digit to file descriptor n, or  the  standard
       input (file descriptor 0) if n is not specified.  digit is closed after
       being duplicated to n.
       Similarly, the redirection operator
              [n]>&digit-
       moves  the  file descriptor digit to file descriptor n, or the standard
       output (file descriptor 1) if n is not specified.
   Opening File Descriptors for Reading and Writing
       The redirection operator
              [n]<>word
       causes the file whose name is the expansion of word to  be  opened  for
       both  reading and writing on file descriptor n, or on file descriptor 0
       if n is not specified.  If the file does not exist, it is created.

ARITHMETIC EVALUATION
       The shell allows arithmetic expressions to be evaluated, under  certain
       circumstances.   Evaluation  is  done  in  fixed-width integers with no
       check for overflow, though division by 0 is trapped and flagged  as  an
       error.   The  operators and their precedence, associativity, and values
       are the same as in the C language.  The following list of operators  is
       grouped  into  levels  of  equal-precedence  operators.  The levels are
       listed in order of decreasing precedence.
       id++ id--
              variable post-increment and post-decrement
       ++id --id
              variable pre-increment and pre-decrement
       - +    unary minus and plus
       ! ~    logical and bitwise negation
       **     exponentiation
       * / %  multiplication, division, remainder
       + -    addition, subtraction
       << >>  left and right bitwise shifts
       <= >= < >
              comparison
       == !=  equality and inequality
       &      bitwise AND
       ^      bitwise exclusive OR
       |      bitwise OR
       &&     logical AND
       ||     logical OR
       expr?expr:expr
              conditional operator
       = *= /= %= += -= <<= >>= &= ^= |=
              assignment
       expr1 , expr2
              comma

       Shell variables are allowed as operands; parameter  expansion  is  per-
       formed before the expression is evaluated.  Within an expression, shell
       variables  may  also  be referenced by name without using the parameter
       expansion syntax.  A shell variable that is null or unset evaluates  to
       0 when referenced by name without using the parameter expansion syntax.
       A  null value evaluates to 0.  A shell variable need not have its inte-
       ger attribute turned on to be used in an expression.

       Operators are evaluated in order  of  precedence.   Sub-expressions  in
       parentheses  are  evaluated first and may override the precedence rules
       above.


SIMPLE COMMAND EXPANSION
       When a simple command is executed, the shell performs the following ex-
       pansions, assignments, and redirections, from left to right.

       1.     The words that the parser has  marked  as  variable  assignments
              (those  preceding  the  command name) and redirections are saved
              for later processing.

       2.     The words that are not variable assignments or redirections  are
              expanded.   If  any words remain after expansion, the first word
              is taken to be the name of the command and the  remaining  words
              are the arguments.

       3.     Redirections are performed as described above under REDIRECTION.

       4.     The text after the = in each variable assignment undergoes tilde
              expansion, parameter expansion, command substitution, arithmetic
              expansion,  and quote removal before being assigned to the vari-
              able.

       If no command name results, the variable assignments affect the current
       shell environment.  Otherwise, the variables are added to the  environ-
       ment  of the executed command and do not affect the current shell envi-
       ronment.  If any of the assignments attempts to assign  a  value  to  a
       readonly  variable,  an error occurs, and the command exits with a non-
       zero status.

       If no command name results, redirections are performed, but do not  af-
       fect  the  current  shell  environment.  A redirection error causes the
       command to exit with a non-zero status.

       If there is a command name left after expansion, execution proceeds  as
       described  below.   Otherwise, the command exits.  If one of the expan-
       sions contained a command substitution, the exit status of the  command
       is  the  exit  status  of  the last command substitution performed.  If
       there were no command substitutions, the command exits with a status of
       zero.


COMMAND EXECUTION
       After a command has been split into words, if it results  in  a  simple
       command  and  an  optional list of arguments, the following actions are
       taken.

       If the command name contains no slashes, 42sh searches each element  of
       the PATH for a directory containing an executable file by that name.  A
       full  search of the directories in PATH is performed.  If the search is
       unsuccessful, the shell prints an error message  and  returns  an  exit
       status of 127.

       If  the  search  is  successful, or if the command name contains one or
       more slashes, the shell executes the named program in a separate execu-
       tion environment.  Argument 0 is set to the name given, and the remain-
       ing arguments to the command are set to the arguments given, if any.

       If this execution fails because the file is not in  executable  format,
       and  the file is not a directory, it is assumed to be a shell script, a
       file containing shell commands.  A subshell is spawned to  execute  it.
       This  subshell  reinitializes itself, so that the effect is as if a new
       shell had been invoked to handle the script, with  the  exception  that
       the  locations of commands remembered by the parent are retained by the
       child.

       If the program is a file beginning with #!, the remainder of the  first
       line  specifies an interpreter for the program.  The shell executes the
       specified interpreter on operating systems that do not handle this exe-
       cutable format themselves.  The arguments to the interpreter consist of
       a single optional argument following the interpreter name on the  first
       line  of  the program, followed by the name of the program, followed by
       the command arguments, if any.


COMMAND EXECUTION ENVIRONMENT
       The shell has an execution environment, which consists of  the  follow-
       ing:


       o      open files inherited by the shell at invocation.

       o      the  current working directory as set by cd, or inherited by the
              shell at invocation

       o      options enabled by shopt

       When a simple command other than a builtin or shell function is  to  be
       executed,  it  is invoked in a separate execution environment that con-
       sists of the following.  Unless otherwise noted, the values are  inher-
       ited from the shell.


       o      the  shell's  open  files,  plus any modifications and additions
              specified by redirections to the command

       o      the current working directory

       o      shell variables marked for export, along with variables exported
              for the command, passed in the environment

       A command invoked  in  this  separate  environment  cannot  affect  the
       shell's execution environment.

       Command  substitution, commands grouped with parentheses, and asynchro-
       nous commands are invoked in a subshell environment that is a duplicate
       of the shell environment, except that traps caught by the shell are re-
       set to the values that the shell inherited from its parent  at  invoca-
       tion.  Builtin commands that are invoked as part of a pipeline are also
       executed in a subshell environment.  Changes made to the subshell envi-
       ronment cannot affect the shell's execution environment.

       If  a command is followed by a & and job control is not active, the de-
       fault standard input for the command is the empty file /dev/null.  Oth-
       erwise, the invoked command inherits the file descriptors of the  call-
       ing shell as modified by redirections.


ENVIRONMENT
       When  a  program  is invoked it is given an array of strings called the
       environment.   This  is  a  list  of  name-value  pairs,  of  the  form
       name=value.

       The  shell provides several ways to manipulate the environment.  On in-
       vocation, the shell scans its own environment and creates  a  parameter
       for  each  name  found,  automatically  marking  it for export to child
       processes.  Executed commands inherit the environment.  The export com-
       mand allow parameters to be added to and deleted from the  environment.
       If  the  value  of  a parameter in the environment is modified, the new
       value becomes part of the environment, replacing the old.  The environ-
       ment inherited by any executed command consists of the shell's  initial
       environment,  whose values may be modified in the shell, less any pairs
       removed by the export command.

       The environment for any simple command or  function  may  be  augmented
       temporarily  by  prefixing  it with parameter assignments, as described
       above in PARAMETERS.  These assignment statements affect only the envi-
       ronment seen by that command.


EXIT STATUS
       For the shell's purposes, a command which exits with a zero exit status
       has succeeded.  An exit status of zero indicates success.   A  non-zero
       exit status indicates failure.

       If a command fails because of an error during expansion or redirection,
       the exit status is greater than zero.

       Shell  builtin  commands return a status of 0 (true) if successful, and
       non-zero (false) if an error occurs while they execute.   All  builtins
       return an exit status of 2 to indicate incorrect usage.

       42sh itself returns the exit status zero.


PROMPTING
       When executing interactively, 42sh displays the primary prompt PS1 when
       it  is  ready  to  read a command, and the secondary prompt PS2 when it
       needs more input to complete  a  command.   42sh  allows  these  prompt
       strings  to  be  customized  by inserting a number of backslash-escaped
       special characters that are decoded as follows:
              \a     an ASCII bell character (07)
              \d     the date in "Weekday Month Date" format (e.g.,  "Tue  May
                     26")
              \D{format}
                     the format is passed to strftime(3) and the result is in-
                     serted into the prompt string; an empty format results in
                     a  locale-specific  time  representation.  The braces are
                     required
              \e     an ASCII escape character (033)
              \h     the hostname up to the first `.'
              \H     the hostname
              \n     newline
              \r     carriage return
              \s     the name of the shell, the basename of  $0  (the  portion
                     following the final slash)
              \u     the username of the current user
              \w     the  current  working  directory,  with $HOME abbreviated
                     with a tilde
              \W     the basename of the current working directory, with $HOME
                     abbreviated with a tilde
              \$     if the effective UID is 0, a #, otherwise a $
              \nnn   the character corresponding to the octal number nnn
              \\     a backslash
              \[     begin a sequence of non-printing characters, which  could
                     be  used  to  embed  a terminal control sequence into the
                     prompt
              \]     end a sequence of non-printing characters


READLINE
       This is the library that handles reading input when using  an  interac-
       tive shell.

   Readline Notation
       In this section, the emacs-style notation is used to denote keystrokes.
       Control  keys  are  denoted by C-key, e.g., C-n means Control-N.  Simi-
       larly, meta keys are denoted by M-key, so M-x means Meta-X.   (On  key-
       boards  without a meta key, M-x means ESC x, i.e., press the Escape key
       then the x key.  This makes ESC the meta prefix.  The combination M-C-x
       means ESC-Control-x, or press the Escape key then hold the Control  key
       while pressing the x key.)

       Readline commands may be given numeric arguments, which normally act as
       a  repeat  count.   Sometimes,  however, it is the sign of the argument
       that is significant.  Passing a negative argument  to  a  command  that
       acts  in the forward direction (e.g., kill-line) causes that command to
       act in a backward direction.  Commands whose  behavior  with  arguments
       deviates from this are noted below.

       When  a command is described as killing text, the text deleted is saved
       for possible future retrieval (yanking).  The killed text is saved in a
       kill ring.  Consecutive kills cause the text to be accumulated into one
       unit, which can be yanked all at once.  Commands which do not kill text
       separate the chunks of text on the kill ring.

   Readline Command Names
       The following is a list of the names of the commands  and  the  default
       key sequences to which they are bound.  Command names without an accom-
       panying key sequence are unbound by default.  In the following descrip-
       tions,  point refers to the current cursor position, and mark refers to
       a cursor position saved by the set-mark command.  The text between  the
       point and mark is referred to as the region.

   Commands for Moving
       beginning-of-line (C-a)
              Move to the start of the current line.
       end-of-line (C-e)
              Move to the end of the line.
       forward-char (C-f)
              Move forward a character.
       backward-char (C-b)
              Move back a character.
       forward-word (M-f)
              Move forward to the end of the next word.  Words are composed of
              alphanumeric characters (letters and digits).
       backward-word (M-b)
              Move  back  to the start of the current or previous word.  Words
              are composed of alphanumeric characters (letters and digits).
       clear-screen (C-l)
              Clear the screen leaving the current line  at  the  top  of  the
              screen.   With  an  argument,  refresh  the current line without
              clearing the screen.

   Commands for Manipulating the History
       accept-line (Newline, Return)
              Accept the line regardless of where the cursor is.  If this line
              is non-empty, add it to the history list according to the  state
              of  the HISTCONTROL variable.  If the line is a modified history
              line, then restore the history line to its original state.
       previous-history (C-p)
              Fetch the previous command from the history list, moving back in
              the list.
       next-history (C-n)
              Fetch the next command from the history list, moving forward  in
              the list.
       beginning-of-history (M-<)
              Move to the first line in the history.
       end-of-history (M->)
              Move  to  the end of the input history, i.e., the line currently
              being entered.

   Commands for Changing Text
       delete-char (C-d)
              Delete the character at point.  If point is at the beginning  of
              the  line,  there  are  no  characters in the line, and the last
              character typed was not bound to delete-char, then return EOF.
       backward-delete-char (Rubout)
              Delete the character behind the cursor.  When  given  a  numeric
              argument, save the deleted text on the kill ring.

   Killing and Yanking
       kill-line (C-k)
              Kill the text from point to the end of the line.
       kill-word (M-d)
              Kill  from  point  to the end of the current word, or if between
              words, to the end of the next word.   Word  boundaries  are  the
              same as those used by forward-word.
       backward-kill-word (M-Rubout)
              Kill  the  word  behind  point.  Word boundaries are the same as
              those used by backward-word.
       delete-horizontal-space (M-\)
              Delete all spaces and tabs around point.
       yank (C-y)
              Yank the top of the kill ring into the buffer at point.

   Miscellaneous
       abort (C-g)
              Abort the current editing command and ring the  terminal's  bell
              (subject to the setting of bell-style).
       prefix-meta (ESC)
              Metafy the next character typed.  ESC f is equivalent to Meta-f.

HISTORY
       The  shell provides access to the command history, the list of commands
       previously typed.  The value of the HISTSIZE variable is  used  as  the
       number  of  commands  to  save in a history list.  The text of the last
       HISTSIZE commands (default 512) is saved.  The shell stores  each  com-
       mand in the history list prior to parameter and variable expansion (see
       EXPANSION  above)  but after history expansion is performed, subject to
       the values of the shell variables HISTIGNORE and HISTCONTROL.
       On startup, the history is initialized from the file named by the vari-
       able HISTFILE (default ~/.42sh_history).  The file named by  the  value
       of  HISTFILE  is  truncated,  if necessary, to contain no more than the
       number of lines specified by the value of HISTFILESIZE.  When an inter-
       active shell exits, the last $HISTSIZE lines are copied from  the  his-
       tory list to $HISTFILE.  If the histappend shell option is enabled (see
       the description of shopt under SHELL BUILTIN COMMANDS below), the lines
       are  appended  to the history file, otherwise the history file is over-
       written.  If HISTFILE is unset, or if the history file  is  unwritable,
       the  history  is not saved.  After saving the history, the history file
       is truncated to contain no more than HISTFILESIZE lines.  If  HISTFILE-
       SIZE is not set, no truncation is performed.

SHELL BUILTIN COMMANDS
       Unless otherwise noted, each builtin command documented in this section
       as accepting options preceded by - accepts -- to signify the end of the
       options.  For example, the :, true, false, and test builtins do not ac-
       cept options.
        .  filename [arguments]
       source filename [arguments]
              Read and execute commands from filename in the current shell en-
              vironment  and  return  the exit status of the last command exe-
              cuted from filename.  If filename does not contain a slash, file
              names in PATH are used to find the  directory  containing  file-
              name.  The file searched for in PATH need not be executable.  If
              the  sourcepath  option  to  the shopt builtin command is turned
              off, the PATH is not searched.  If any arguments  are  supplied,
              they become the positional parameters when filename is executed.
              Otherwise  the  positional parameters are unchanged.  The return
              status is the status of  the  last  command  exited  within  the
              script (0 if no commands are executed), and false if filename is
              not found or cannot be read.

       alias [-p] [name[=value] ...]
              Alias prints the list of aliases in the form alias name=value on
              standard  output.   When arguments are supplied, an alias is de-
              fined for each name whose value is given.  A trailing  space  in
              value  causes the next word to be checked for alias substitution
              when the alias is expanded.  For each name in the argument  list
              for  which no value is supplied, the name and value of the alias
              is printed.  Alias returns true unless a name is given for which
              no alias has been defined.

       break [n]
              Exit from within a for, while, until, or select loop.  If  n  is
              specified,  break  n  levels.   n must be >= 1.  If n is greater
              than the number of enclosing loops, all enclosing loops are  ex-
              ited.  The return value is 0 unless the shell is not executing a
              loop when break is executed.

       cd [-L|-P] [dir]
              Change  the  current directory to dir.  The variable HOME is the
              default dir.  The variable CDPATH defines the  search  path  for
              the  directory  containing  dir.  Alternative directory names in
              CDPATH are separated by a colon (:).  A null directory  name  in
              CDPATH  is  the  same as the current directory, i.e., ``.''.  If
              dir begins with a slash (/), then CDPATH is not used. The -P op-
              tion says to use the physical  directory  structure  instead  of
              following  symbolic  links  (see  also  the -P option to the set
              builtin command); the -L option forces symbolic links to be fol-
              lowed.  An argument of - is equivalent to $OLDPWD.   If  a  non-
              empty  directory  name from CDPATH is used, or if - is the first
              argument, and the directory change is successful,  the  absolute
              pathname of the new working directory is written to the standard
              output.   The return value is true if the directory was success-
              fully changed; false otherwise.

       continue [n]
              Resume the next iteration of the enclosing for, while, until, or
              select loop.  If n is specified, resume  at  the  nth  enclosing
              loop.   n  must be >= 1.  If n is greater than the number of en-
              closing loops, the last enclosing loop (the ``top-level''  loop)
              is  resumed.  The return value is 0 unless the shell is not exe-
              cuting a loop when continue is executed.

       echo [-neE] [arg ...]
              Output the args, separated by spaces,  followed  by  a  newline.
              The return status is always 0.  If -n is specified, the trailing
              newline  is  suppressed.  If the -e option is given, interpreta-
              tion of the following backslash-escaped characters  is  enabled.
              The  -E option disables the interpretation of these escape char-
              acters, even on systems where they are interpreted  by  default.
              The  xpg_echo  shell option may be used to dynamically determine
              whether or not echo expands these escape characters by  default.
              echo does not interpret -- to mean the end of options.  echo in-
              terprets the following escape sequences:
              \a     alert (bell)
              \b     backspace
              \c     suppress trailing newline
              \e     an escape character
              \f     form feed
              \n     new line
              \r     carriage return
              \t     horizontal tab
              \v     vertical tab
              \\     backslash
              \0nnn  the  eight-bit  character  whose value is the octal value
                     nnn (zero to three octal digits)
              \xHH   the eight-bit character whose value  is  the  hexadecimal
                     value HH (one or two hex digits)

       exit [n]
              Cause  the  shell  to exit with a status of n.  If n is omitted,
              the exit status is that of the last command executed.  A trap on
              EXIT is executed before the shell terminates.

       export [-fn] [name[=word]] ...
       export -p
              The supplied names are marked for automatic export to the  envi-
              ronment  of subsequently executed commands.  If the -f option is
              given, the names refer to functions.  If no names are given,  or
              if  the  -p option is supplied, a list of all names that are ex-
              ported in this shell is printed.  The -n option causes  the  ex-
              port  property to be removed from each name.  If a variable name
              is followed by =word, the value of the variable is set to  word.
              export  returns  an exit status of 0 unless an invalid option is
              encountered, one of the names is  not  a  valid  shell  variable
              name, or -f is supplied with a name that is not a function.

       history [n]
       history -c
       history -r [filename]
              With no options, display the command history list with line num-
              bers.  Lines listed with a * have been modified.  An argument of
              n  lists  only the last n lines.  If filename is supplied, it is
              used as the name of the history file; if not, the value of HIST-
              FILE is used.  Options, if supplied, have  the  following  mean-
              ings:
              -c     Clear the history list by deleting all the entries.
              -r     Read the contents of the history file and use them as the
                     current history.
              shopt [-qsu] [optname ...]
                     Toggle the values of variables controlling optional shell
                     behavior.   With  no  options, a list of all settable op-
                     tions is displayed, with an indication of whether or  not
                     each is set.  Other options have the following meanings:
                     -s     Enable (set) each optname.
                     -u     Disable (unset) each optname.
                     -q     Suppresses  normal output (quiet mode); the return
                            status indicates whether the optname is set or un-
                            set.  If multiple optname arguments are given with
                            -q, the return status is zero if all optnames  are
                            enabled; non-zero otherwise.

                     If either -s or -u is used with no optname arguments, the
                     display  is limited to those options which are set or un-
                     set, respectively.  Unless otherwise noted, the shopt op-
                     tions are disabled (unset) by default.

                     The return status when listing options  is  zero  if  all
                     optnames  are  enabled, non-zero otherwise.  When setting
                     or unsetting options, the return status is zero unless an
                     optname is not a valid shell option.

                     The list of shopt options is:

                     ast_print
                             If set, 42sh prints the ast in a PNG file.
                     dotglob If set, 42sh includes filenames beginning with  a
                             `.' in the results of pathname expansion.
                     expand_aliases
                             If set, aliases are expanded.  This option is en-
                             abled by default for interactive shells.
                     extglob If  set,  the  extended pattern matching features
                             are enabled.
                     nocaseglob
                             If set, 42sh matches filenames in a case-insensi-
                             tive fashion
                     nullglob
                             If set, 42sh allows patterns which match no files
                             to expand to a null  string,  rather  than  them-
                             selves.
                     sourcepath
                             If  set, the source (.) builtin uses the value of
                             PATH to find the directory  containing  the  file
                             supplied  as an argument.  This option is enabled
                             by default.
                     xpg_echo
                             If set, the echo builtin expands backslash-escape
                             sequences by default.
              unalias [-a] [name ...]
                     Remove each name from the list of defined aliases.  If -a
                     is supplied, all alias definitions are removed.  The  re-
                     turn  value  is  true unless a supplied name is not a de-
                     fined alias.

FILES
		[files]

AUTHORS
       42sh was made by :

       - [name] ([login]) - [email]

42SH                            [DATE]                        42SH(1)
